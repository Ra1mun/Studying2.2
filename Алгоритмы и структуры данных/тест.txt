#include <iostream>
#include <ctime>
#include <float.h>
#include "Point.h"
#include "Sort.h"

double distance(Point p1, Point p2)
{
    return sqrt(pow(p2.x - p1.x, 2) + pow(p2.y - p1.y, 2));
}

double minWeight(double* weights, int& minIndex, size_t size) {
    using namespace std;
    double result = DBL_MAX;
    for (int i = 0; i < size; i++) {
        if (weights[i] < result) {
            result = weights[i];
            minIndex = i;
        }
            
    }

    return result;
}

int main()
{
    using namespace std;

    srand(time(nullptr));

    int N = 5;
    int K = 3;
    int minPosition = -10, maxPosition = 10;


    //сгенерировать N случайных точек
    Point* points = new Point[N];
    for (int i = 0; i < N; i++) {
        Point newPoint(rand() % (maxPosition - minPosition + 1) + minPosition,
            rand() % (maxPosition - minPosition + 1) + minPosition);

        points[i] = newPoint;
    }

    //считая данные точки вершинами полного взвешенного графа (веса – расстояния между парами точек),
    //выделить ребра минимального остова
    double* minLengths = new double[N - 1];
    int** indexMinPoints = new int*[N - 1];
    for (int i = 0; i < N - 1; i++) {
        indexMinPoints[i] = new int[2];
        indexMinPoints[i][0] = i;
    }

    for (int currentPoint = 0; currentPoint < N - 1; currentPoint++) {
        double* weights = new double[N - currentPoint - 1];
        int countPoints = 0;
        for (int j = currentPoint + 1; j < N; j++) {
            weights[countPoints] = distance(points[currentPoint], points[j]);
            countPoints++;
        }

        int index;
        minLengths[currentPoint] = minWeight(weights, index, N - currentPoint - 1);
        indexMinPoints[currentPoint][1] = index;

        delete[] weights;
    }

    //отсортировать ребра остова по возрастанию весов
    int* id = new int[N - 1];
    for (int i = 0; i < N - 1; i++)
        id[i] = i;

    Sort<double> sort;
    sort.PiramidSort(minLengths, id, N - 1);


    //проверка
    int x = indexMinPoints[0][0];
    int y = indexMinPoints[0][1];

    cout << points[x].x << ',' << points[x].y << ' ' << points[y].x << ',' << points[y].y;
    cout << "actual min: " << minLengths[0] << '\n';
    cout << "excepted min: " << distance(points[x], points[y]) << '\n';

    //по начальным N-K ребрам отсортированного массива построить матрицу смежности неориентированного графа
    //и выделить K компонент связности (вершины каждой компоненты образуют один кластер)

    for (int i = 0; i < N - 1; i++) {
        delete[] indexMinPoints[i];
    }

    delete[] indexMinPoints;
    delete[] points;
    delete[] minLengths;
}
